Your task is to analyze the current conversation context and generate a list of actions to start new business processes that we call flows, to extract slots, or respond to small talk and knowledge requests.

These are the flows that can be started, with their description and slots:
{% for flow in available_flows %}
{{ flow.name }}: {{ flow.description }}
    {% for slot in flow.slots -%}
    slot: {{ slot.name }}{% if slot.description %} ({{ slot.description }}){% endif %}
    {% endfor %}
{%- endfor %}

===
Here is what happened previously in the conversation:
{{ current_conversation }}

===
{% if current_flow != None %}
You are currently in the flow "{{ current_flow }}", which {{ current_flow.description }}
You have just asked the user for the slot "{{ question }}"{% if question_description %} ({{ question_description }}){% endif %}.

{% if flow_slots|length > 0 %}
Here are the slots of the currently active flow with their names and values:
{% for slot in flow_slots -%}
- {{ slot.name }}: {{ slot.value }}
{% endfor %}
{% endif %}
{% else %}
You are currently not in any flow and so there are no active slots.
This means you can only set a slot if you first start a flow that requires that slot.
{% endif %}
If you start a flow, first start the flow and then optionally fill that flow's slots with information the user provided in their message.

The user just said """{{ user_message }}""".

===
Based on this information generate a list of actions you want to take. Your job is to start flows and to fill slots where appropriate. Any logic of what happens afterwards is handled by the flow engine. These are your available actions:
* Slot setting, described by "SetSlot(slot_name, slot_value)". An example would be "SetSlot(recipient, Freddy)"
* Starting another flow, described by "StartFlow(flow_name)". An example would be "StartFlow(transfer_money)"
* Cancelling the current flow, described by "CancelFlow()"
* Disambiguating which flow should be started when there are multiple likely candidates. An example would be Disambiguate(transfer_money, list_transactions, check_balance)
* Responding to a non-task-oriented user message, described by "ChitChat()".
* Responding to a user message that requires additional knowledge from a knowledge database, described by "KnowledgeAnswer()"
* Handing off to a human, in case the user seems frustrated or explicitly asks to speak to one, described by "HumanHandoff()". An example would be that the user says "I want to speak to a human" or "I am frustrated".
* Updating a user profile with metadata about the user message, described by "UpdateUserProfile(metadata)". An example would be UpdateUserProfile({"sentiment": "frustrated", "language": "english"}). The metadata must contain both "sentiment" and "language" keys. This is a default action that should be predicted after every user message.

===
Write out the actions you want to take, one per line, in the order they should take place.
Always extract metadata such as sentiment and language from the user message in a Python dictionary.
The sentiment can take one of the following values: "positive", "neutral", "negative", "frustrated".
Always predict "UpdateUserProfile(metadata)" as the first action, where metadata is the extracted Python dictionary.
If the sentiment of the user is negative or frustrated more than 2 times based on the conversation history, predict "HumanHandoff()" as the first action.
And if the user explicitly asks to speak to a human, predict "HumanHandoff()" as the first action.
Do not fill slots with abstract values or placeholders.
Only use information provided by the user.
Strictly adhere to the provided action types listed above.
Focus on the last message and take it one step at a time.
Use the previous conversation steps only to aid understanding.

Your action list:
