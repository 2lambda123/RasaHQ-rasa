---
id: nlu-training-data
sidebar_label: NLU Training Data
title: NLU Training Data
description: Read more about how to format training data with Rasa NLU for open source natural language processing.
abstract: NLU training data stores structured information about user messages.
---

The goal of NLU (Natural Language Understanding) is to extract structured information from user messages. This usually includes the user's [intent](glossary.mdx#intent) and any 
[entities](glossary.mdx#entities) their message contains.

## Training Examples

NLU training data consists of example user utterances categorized by
intent. 
To make it easier to use your intents, give them names that relate to what the user wants to accomplish with that intent, keep them in lowercase and avoid spaces and special characters. 

:::note
The `/` symbol is reserved as a delimiter to separate retrieval intents from response text identifiers. Make sure not
to use it in the name of your intents.

:::

Training examples can also include entities. You can
add extra information such as **[regular expressions](#regular-expression-features)** and **[lookup tables](#lookup-tables)** to your
training data to help the model identify intents and entities correctly. 


## Entities

[Entities](glossary.mdx#entity) are structured pieces of information inside a user message. 
For entity extraction to work, you need to either specify training data to train an ML model or you need to define [regular expressions](#regular-expressions-for-entity-extraction) to extract entities using the [`RegexEntityExtractor`](components.mdx#regexentityextractor) based on a character pattern.

When deciding which entities you need to extract, think about what information your assistant needs for its user goals. If the user will provide a piece of information as part of a user message, that might be an entity you want to extract. The user might provide additional pieces of information that you don't need for any user goal; you don't need to extract these as entities.



## Synonyms

Synonyms map extracted entity to a value other than the literal text extracted. 
See the [training data format](./training-data-format.mdx) documentation for details on how to annotate entities with synonyms in your training data.

You should define synonyms when there are multiple ways users refer to the same
thing. Think of the end goal of extracting an entity, and figure out from there which values should be considered equivalent. 

Let's say you had an entity `account` that you use to look up the user's balance. One of the possible account types is "credit". Your users also refer to their "credit" account as "credit
account" and "credit card account".

In this case, you could define "credit card account" and "credit account" as
**synonyms** to "credit":

```yaml-rasa
nlu:
- synonym: credit
  examples: |
    - credit card account
    - credit account
```

Then, if either of these phrases is extracted as an entity, it will be
mapped to the **value** `credit`.

:::note Needs Training Examples
Synonym mapping only happens **after** entities have been extracted.
That means that your training examples should include the synonym examples
(`credit card account` and `credit account`) so that the model will learn to
recognize these as entities and replace them with `credit`.
:::

## Regular Expressions

You can use regular expressions to improve intent classification and
entity extraction in combination with the [`RegexFeaturizer`](components.mdx#regexfeaturizer) and [`RegexEntityExtractor`](components.mdx#regexentityextractor) components in the pipeline.


### Regular Expressions for Intent Classification

You can use regular expressions to improve intent classification by including the `RegexFeaturizer` component in your pipeline. When using the `RegexFeaturizer`, a regex does not act as a rule for classifying an intent. It only provides a feature that the intent classifier will use
to learn patterns for intent classification.
Currently, all intent classifiers make use of available regex features.

The name of a regex in this case is a human readable description. It can help you remember what a regex is used for, and it is the title of the corresponding pattern feature. It does not have to match any intent or entity name. A regex for greeting might look like this:

```yaml-rasa
nlu:
- regex: greet
  examples: |
    - hey[^\\s]*
```

The intent being matched could be `greet`,`say_hi`, `hallo` or anything else.

Try to create your regular expressions in a way that they match as few
words as possible. E.g. using `hey[^\\s]*` instead of `hey.*`, as the
later one might match the whole message whereas the first one only
matches a single word.

### Regular Expressions for Entity Extraction

If your entity has a deterministic structure (like an account number), you can use regular expressions in one of two ways:

1. As features for the [`RegexFeaturizer`](components.mdx#regexfeaturizer) component in the pipeline.

  When used as as features for the `RegexFeaturizer` the
  name of the regular expression does not matter.

  Regex features for entity extraction
  are currently only supported by the `CRFEntityExtractor` and the
  `DIETClassifier` component. Other entity extractors, like
  `MitieEntityExtractor` or `SpacyEntityExtractor`, won't use the generated
  features and their presence will not improve entity recognition for
  these extractors.

2. For rule-based entity extraction using the [`RegexEntityExtractor`](components.mdx#regexentityextractor) component in the pipeline.

  When using the `RegexEntityExtractor`, the name of the regular expression should
  match the name of the entity you want to extract.

In both cases, the format for defining the regex is the same.
For example, a regex for extracting a bank account number that is 10-12 digits long might look like this:

```yaml-rasa
nlu:
- regex: account_number
  examples: |
    - \d{10:12}
```


:::note Combining with Regexes

When using the `RegexFeaturizer`, a regular expression only provides a feature
that helps the model learn an association between intents/entities and inputs
that fit the regular expression. In order for the model to learn this association,
you must provide example inputs that include that regular expression!
:::




## Lookup Tables

Lookup tables are lists of words used to generate
case-insensitive regex patterns that are added to the regex features.

:::note Combining with Regexes

If you are using lookup tables in combination with the `RegexFeaturizer`,
there must be a few examples of matches in your training data. Otherwise the
model will not learn to use the lookup table match features.
:::

:::caution Keep your lookup tables clean

You have to be careful when you add data to the lookup table. For example, if there
are false positives or other noise in the table, this can hurt performance. Make
sure your lookup tables contain clean data!
:::


## Entities Roles and Groups

:::caution
This feature is experimental.
We introduce experimental features to get feedback from our community, so we encourage you to try it out!
However, the functionality might be changed or removed in the future.
If you have feedback (positive or negative) please share it with us on the [forum](https://forum.rasa.com).

:::

Assigning custom entity labels to words, allow you to define certain concepts in the data.
For example, we can define what a city is:

```
I want to fly from [Berlin]{"entity": "city"} to [San Francisco]{"entity": "city"} .
```

However, sometimes you want to specify entities even further.
Let's assume we want to build an assistant that should book a flight for us.
The assistant needs to know which of the two cities in the example above is the departure city and which is the
destination city.
`Berlin` and `San Francisco` are still cities, but they play a different role in our example.
To distinguish between the different roles, you can assign a role label in addition to the entity label.

```
- I want to fly from [Berlin]{"entity": "city", "role": "departure"} to [San Francisco]{"entity": "city", "role": "destination"}.
```

You can also group different entities by specifying a group label next to the entity label.
The group label can, for example, be used to define different orders.
In the following example we use the group label to reference what toppings goes with which pizza and
what size which pizza has.

```
Give me a [small]{"entity": "size", "group": "1"} pizza with [mushrooms]{"entity": "topping", "group": "1"} and
a [large]{"entity": "size", "group": "2"} [pepperoni]{"entity": "topping", "group": "2"}
```

See [Training Data Format](training-data-format.mdx#entities) for details on how to define entities with roles and groups in your training data.

The entity object returned by the extractor will include the detected role/group label.

```json
{
  "text": "Book a flight from Berlin to SF",
  "intent": "book_flight",
  "entities": [
    {
      "start": 19,
      "end": 25,
      "value": "Berlin",
      "entity": "city",
      "role": "departure",
      "extractor": "DIETClassifier",
    },
    {
      "start": 29,
      "end": 31,
      "value": "San Francisco",
      "entity": "city",
      "role": "destination",
      "extractor": "DIETClassifier",
    }
  ]
}
```

:::note
Composite entities are currently only supported by the [DIETClassifier](./components.mdx#dietclassifier) and [CRFEntityExtractor](./components.mdx#crfentityextractor).

:::

In order to properly train your model with entities that have roles/groups, make sure to include enough training data
examples for every combination of entity and role/group label.
Also make sure to have some variations in your training data, so that the model is able to generalize.
For example, you should not only have example like `fly FROM x TO y`, but also include examples like
`fly TO y FROM x`.

To fill slots from entities with a specific role/group, you need to either define a custom slot mappings using
[Forms](forms.mdx) or use [Custom Actions](custom-actions.mdx) to extract the corresponding entity directly from the tracker.


### BILOU Entity Tagging

The [DIETClassifier](./components.mdx#dietclassifier) and [CRFEntityExtractor](./components.mdx#crfentityextractor)
have the option `BILOU_flag`, which refers to a tagging schema that can be
used by the machine learning model when processing entities.
`BILOU` is short for Beginning, Inside, Last, Outside, and Unit-length.

For example, the training example

```
[Alex]{"entity": "person"} is going with [Marty A. Rick]{"entity": "person"} to [Los Angeles]{"entity": "location"}.
```

is first split into a list of tokens. Then the machine learning model applies the tagging schema
as shown below depending on the value of the option `BILOU_flag`:

| token   | `BILOU_flag = true`  | `BILOU_flag = false`  |
|---------|----------------------|-----------------------|
| alex    | U-person             | person                |
| is      | O                    | O                     |
| going   | O                    | O                     |
| with    | O                    | O                     |
| marty   | B-person             | person                |
| a       | I-person             | person                |
| rick    | L-person             | person                |
| to      | O                    | O                     |
| los     | B-location           | location              |
| angeles | L-location           | location              |

The BILOU tagging schema is richer compared to the normal tagging schema. It may help to improve the
performance of the machine learning model when predicting entities.

:::note inconsistent BILOU tags
When the option `BILOU_flag` is set to `True`, the model may predict inconsistent BILOU tags, e.g.
`B-person I-location L-person`. Rasa Open Source uses some heuristics to clean up the inconsistent BILOU tags.
For example, `B-person I-location L-person` would be changed into `B-person I-person L-person`.
:::
