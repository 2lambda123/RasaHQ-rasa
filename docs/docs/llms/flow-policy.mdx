---
id: flow-policy
sidebar_label: Flow Policy
title: Flow Policy
abstract: |
  This is a guide to implementing and managing conversational flows using the FlowPolicy.
---

import RasaDiscoveryBanner from "@theme/RasaDiscoveryBanner";
import flowStackEvolution from "./flow_stack_evolution.png";
import flowStackOverview from "./flow_stack.png";

<RasaDiscoveryBanner />

Rasa's Flow Policy is a state machine that allows you to manage and control your
chatbot's conversational flows. It facilitates the integration of your business
logic with machine learning capabilities.

The Flow Policy oversees your bot's state, handles state transitions, and
triggers new flows when needed. The "Flow Stack" represents all started but
incomplete flows and refers to steps defined in the
[flows specification](../flows.mdx).

<Image
  img={flowStackOverview}
  caption="Flow Stack represents the current state of the conversation referring to a flow."
  alt=""
/>

Using the Flow Policy, you can encapsulate your logic into flows, thereby
guiding the conversation based on user input and system response. Other
classifiers adjust the underlying state machine to handle edge cases.

For more detailed information on defining flows, refer to the
[flows specification](../flows.mdx).

## Adding the FlowPolicy to your bot

The Flow Policy can be integrated like [any other policy](../policies.mdx). It
involves two steps:

1. Configure the `FlowPolicy` in your `config.yml` file:

   ```yaml-rasa title="config.yml"
   policies:
   # - ...
     - name: rasa.core.policies.flow_policy.FlowPolicy
   # - ...
   ```

2. Add flows to your bot as per the [flows specification](../flows.mdx). This
   step involves defining the states and transitions that your bot should
   recognize and react to.

Once added, the `FlowPolicy` will read all defined flows from your training data
and apply them.

## How does it work?

The `FlowPolicy` employs a Flow stack structure (Last In First Out) along with
internal slots to manage your bot's state.

### Managing the State

Your bot's state is managed using a "flow stack". The flow stack stores the
current position in each started flow. The stack follows a "last in, first out"
sequence. The last started flow will be completed first, and then earlier
inserted flows will continue. The flow stack is stored in the `flow_stack` slot.

Here's an example flow and a conversation currently using it:

```yaml title="flows.yml"
flows:
  transfer_money:
    description: This flow enables users to send money to friends and family.

    steps:
      - id: "start"
        intent: transfer_money
        next: "ask_recipient"
      - id: "ask_recipient"
        question: transfer_money_recipient
        next: "ask_amount"
      - id: "ask_amount"
        question: transfer_money_amount_of_money
        next: "check_transfer_funds"
    # - ...
```

The flow can be started with the intent `transfer_money`. The first step in the
flow is `ask_recipient`. A correction by the user, _"oh sorry I meant John"_, 
initiates a correction flow. This correction is not explicitly modeled in 
the `transfer_money` flow; it's handled by a conversational pattern:

<Image
  img={flowStackEvolution}
  caption="Flow stack changes during a correction of a previous user input"
  alt=""
/>



The correction flow only executes when the user wants to correct a previous
input. Once triggered, it's placed on top of the flow stack for execution.

For the `transfer_money` flow, the correction flow is an interruption. Once
completed, the `transfer_money` flow resumes. Before its res umption, a
`resume_flow` flow is activated. You can customize what happens in `resume_flow`
and `correction` flows in [Handling Unhappy Paths](./unhappy-paths.mdx).

Upon completion of the `resume_flow` flow, the `transfer_money` flow resumes,
and the bot returns to the state before the correction flow started. The
`transfer_money` flow will re-ask the interrupted question.

The `resume_flow` and `correction` flows are conversational patterns not
explicitly modeled in the `transfer_money` flow. The `FlowPolicy` automatically
triggers them when needed. For more details on defining conversational patterns,
refer to [Handling Unhappy Paths](./unhappy-paths.mdx).

### Transitioning Between States

The `FlowPolicy` transitions between states either in response to user inputs or
after an action's completion. Initially, it awaits user input. Once received, it
advances the state of the machine until an action prediction is made. After
completing the action and incorporating its result, it moves to the next state.

### Starting New Flows

Starting a new flow in the `FlowPolicy` can occur in two ways: by user input
matching the first step in a flow, or by predicting the "flow action".

#### User Input

A user message like _"I want to transfer money"_ will trigger the
`transfer_money` flow, provided this flow is defined to be initiated by such a
message:

```yaml title="flows.yml"
flows:
  transfer_money:
    name: Transfer money
    steps:
      - id: "1"
        intent: transfer_money
        action: action_transfer_money
      - id: "2"
        action: utter_lets_transfer_money
    # - ...
```

Here, the NLU model predicts the `transfer_money` intent, and as a result, the
`FlowPolicy` initiates the `transfer_money` flow.

#### Predicting Flow Actions

Another policy predicting the action `flow_transfer_money` will result in the
`FlowPolicy` initiating the `transfer_money` flow.

### Interruptions and Digressions

Flows and their specifications should ideally model the happy path of a
conversation. The `FlowPolicy` depends on other components to identify
digressions and interruptions and interrupt the flow accordingly. For details on
which digressions and interruptions the flow policy can handle, refer to
[Handling Unhappy Paths](./unhappy-paths.mdx).

For example, the user message _"oh sorry I meant John"_ is a correction to a
prior input. The `FlowPolicy` depends on another component, like the
[LLM Command Generator](./llm-command-generator.mdx), to identify it as a correction
and set the corresponding slots. Based on this, the `FlowPolicy` initiates the
correction flow.

### Cancelling an initiated correction

Users have the option to cancel a correction initiated by them by adjusting the default
 flow for pattern correction. The provided example demonstrates how to modify the 
 default flow effectively. The confirm_correction question can be used to confirm if 
 the user wants to accept the correction that was initiated. A custom action is 
 used to set the values of the slot before correction.

````yaml title="flows.yml"
flows:
  pattern_correction:
    description: A meta flow that should be started to correct a previous user input.

    steps:
      - id: "0"
        question: confirm_correction
        next:
          - if: confirm_correction
            then: "1"
          - else: "2"
      - id: "1"
        action: utter_corrected_previous_input
      - id: "2"
        action: action_cancel_correction
        next: "3"
      - id: "3"
        action: utter_not_corrected_previous_input
```

```python
from typing import Any, Dict
from rasa_sdk import Action, Tracker
from rasa_sdk.events import SlotSet
from rasa_sdk.executor import CollectingDispatcher


class CancelCorrectionTemplate(Action):

    def name(self) -> str:
        return "action_cancel_correction"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker, domain: Dict[str, Any]):
        events = []
        CORRECTED_SLOTS_SLOT = "rasa_corrected_slots"
        corrected_slots = tracker.get_slot(CORRECTED_SLOTS_SLOT)
        if corrected_slots and tracker.latest_message.intent["name"] == "deny":
            for corrected_slot in corrected_slots:
                found_first_event = False
                for event in reversed(tracker.events):
                    if isinstance(event, SlotSet) and event.key == corrected_slot:
                        if not found_first_event:
                            found_first_event = True
                        else:
                            events.append(SlotSet(event.key, event.value))
                            break
        events.append(SlotSet(CORRECTED_SLOTS_SLOT, None))
        return events

```

## Configuration

No additional configuration is required for the FlowPolicy beyond what's already
outlined above.

## FAQs

### Can FlowPolicy be used with other Policies?

Currently, we recommend not using the `FlowPolicy` in conjunction with the
`RulePolicy`. The `RulePolicy` isn't aware of the flow stack and may interfere
with the `FlowPolicy`.

### What triggers a flow start?

A flow can be initiated in several ways:

1. One flow can ["link" to another flow](../flows.mdx#next-property), which will
   initiate the linked flow and return to the original flow once the linked flow
   completes.
2. A flow starts when the user message matches the
   [`user_message` step](../flows.mdx#user-message) of the flow. A
   match is determined by the intent and entities of the user message.
3. Flows, which are conversational patterns (e.g. correction, resume flow), are
   automatically initiated by the `FlowPolicy` when needed.
4. A flow starts when another policy predicts the corresponding flow action
   named `flow_{flow_name}`. This action pushes the flow onto the flow stack,
   and the `FlowPolicy` executes it.
