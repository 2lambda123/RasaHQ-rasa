---
id: domain
sidebar_label: Domain
title: Domain
abstract: The domain defines the universe in which your assistant operates.
---

In Rasa, your `domain` defines the universe in which your assistant operates.
Specifically, it lists:

* The `responses` that can be used as templated messages to send to a user.
* The custom `actions` that can be predicted by dialogue policies.
* The `slots` that act as your assistant's memory throughout a conversation.
* Session configuration parameters including inactivity timeout.

If you are building an NLU-based assistant, refer to [this page](../building-classic-assistants/domain.mdx) to see how 
intents, entities, slot mappings, and slot featurization can be configured in 
your domain. 

## Multiple Domain Files

The domain can be defined as a single YAML file or split across multiple files in a directory.
When split across multiple files, the domain contents will be read and automatically merged together.

Using the [command line interface](../command-line-interface.mdx#rasa-train),
you can train a model with split domain files by running:

```bash
rasa train --domain path_to_domain_directory
```


## Responses

Responses are actions that send a message to a user without running any custom code or
returning events. These responses can be defined directly in the domain file under the `responses` key
and can include rich content such as buttons and attachments. For more information on responses and how to define them,
see [Responses](./responses.mdx).

## Actions

[Actions](./actions.mdx) are the things your bot can actually do.
For example, an action could:

- respond to a user,

- make an external API call,

- query a database, or

- just about anything!

All [custom actions](./custom-actions.mdx) should be listed in your domain.


## Slots

Slots are your assistant's memory. They act as a key-value store
which can be used to store information the user provided (e.g their home city)
as well as information gathered about the outside world (e.g. the result of a
database query).

Slots are defined in the slots section of your domain with their name,
[type](./domain.mdx#slot-types) and default value.
Different slot types exist to restrict the possible values a slot can take.

### Slot Types

#### Text Slot

- **Example**

  ```yaml-rasa
  slots:
     cuisine:
        type: text
  ```
- **Allowed Values**

  Any string

#### Boolean Slot

- **Example**

  ```yaml-rasa
  slots:
     confirmation:
        type: bool
  ```
- **Allowed Values**

  `True` or `False`

#### Categorical Slot

- **Example**

  ```yaml-rasa
  slots:
    risk_level:
      type: categorical
      values:
        - low
        - medium
        - high
  ```

#### Float Slot

- **Example**

  ```yaml-rasa
  slots:
    temperature:
      type: float
  ```

#### Any Slot

- **Example**

  ```yaml-rasa
  slots:
    shopping_items:
      type: any
  ```


### Initial slot values

You can provide an initial value for any slot in your domain file:

```yaml-rasa
slots:
  num_fallbacks:
    type: float
    initial_value: 0
```

### Slot Mappings

Some info about slot mappings : TODO

#### Custom Slot Mappings

## Session configuration

A conversation session represents the dialogue between the assistant and the user.
Conversation sessions can begin in three ways:

1. the user begins the conversation with the assistant,

2. the user sends their first message after a configurable period of inactivity, or

3. a manual session start is triggered with the `/session_start` intent message.

You can define the period of inactivity after which a new conversation
session is triggered in the domain under the `session_config` key.

Available parameters are:

- `session_expiration_time` defines the time of inactivity in minutes after which a
  new session will begin.
- `carry_over_slots_to_new_session` determines whether
  existing set slots should be carried over to new sessions.

The default session configuration looks as follows:

```yaml-rasa
session_config:
  session_expiration_time: 60  # value in minutes, 0 means infinitely long
  carry_over_slots_to_new_session: true  # set to false to forget slots between sessions
```

This means that if a user sends their first message after 60 minutes of inactivity, a
new conversation session is triggered, and that any existing slots are carried over
into the new session. Setting the value of `session_expiration_time` to `0` means
that sessions will not end (note that the `action_session_start` action will still
be triggered at the very beginning of conversations).

:::note
A session start triggers the default action `action_session_start`. Its default
implementation moves all existing slots into the new session. Note that all
conversations begin with an `action_session_start`. Overriding this action could
for instance be used to initialize the tracker with slots from an external API
call, or to start the conversation with a bot message. The docs on
[Customizing the session start action](./default-actions.mdx#customization) shows you how to do that.

:::


## Select which actions should receive domain

:::info New in 3.4.3
You can control if an action should receive a domain or not.
:::

To do this you must first enable selective domain in you endpoint configuration for
`action_endpoint` in `endpoints.yml`.

```yaml-rasa title="endpoints.yml"
action_endpoint:
 url: "http://localhost:5055/webhook" # URL to your action server
 enable_selective_domain: true
```

**After selective domain for custom actions is enabled, domain will be sent only to
those custom actions which have specifically stated that they need it.**
Custom actions inheriting from rasa-sdk [`FormValidationAction`](../action-server/validation-action.mdx#formvalidationaction-class)
parent class are an exception to this rule as they will always have the domain sent to them.
To specify if an action needs the domain add `{send_domain: true}` to custom action in the list
of actions in `domain.yml`:

```YAML
# domain.yml
actions:
  - action_hello_world: {send_domain: True} # will receive domain
  - action_calculate_mass_of_sun # will not receive domain
  - validate_my_form # will receive domain
```
